import Foundation

// MARK: - API Response Models

struct APIResponse<T: Codable>: Codable {
    let code: Int
    let message: String
    let data: T
}

struct PerfumesData: Codable {
    let perfumes: [PerfumeResponseData]
}

struct PerfumeResponseData: Codable {
    let name: String
    let brand: String
    let imageUrl: String
    
    enum CodingKeys: String, CodingKey {
        case name
        case brand
        case imageUrl = "image_url"
    }
    
    // PerfumeResponseDataë¥¼ Perfume ëª¨ë¸ë¡œ ë³€í™˜
    func toPerfume() -> Perfume {
        // ë°±ì—”ë“œ ì´ë¯¸ì§€ URLì´ ìˆìœ¼ë©´ ì‚¬ìš©, ì—†ê±°ë‚˜ ë¹ˆ ê°’ì´ë©´ í”Œë ˆì´ìŠ¤í™€ë” ìƒì„±
        let finalImageURL = imageUrl.trimmingCharacters(in: .whitespaces).isEmpty ? 
            generateSafeImageURL(for: name, brand: brand) : imageUrl
        
        return Perfume(
            id: "\(brand.lowercased().replacingOccurrences(of: " ", with: "_"))_\(name.lowercased().replacingOccurrences(of: " ", with: "_"))",
            name: name,
            brand: brand,
            imageURL: finalImageURL,
            price: 0.0, // ê¸°ë³¸ê°’
            description: "\(brand)ì˜ \(name) í–¥ìˆ˜ì…ë‹ˆë‹¤.", // ê¸°ë³¸ ì„¤ëª…
            notes: PerfumeNotes(top: [], middle: [], base: []), // ë¹ˆ ë…¸íŠ¸
            rating: 4.0, // ê¸°ë³¸ í‰ì 
            emotionTags: [], // ë¹ˆ ê°ì • íƒœê·¸
            similarity: 0.0 // ê¸°ë³¸ ìœ ì‚¬ë„
        )
    }
    
    // ì•ˆì •ì ì¸ ì´ë¯¸ì§€ URL ìƒì„± í—¬í¼ í•¨ìˆ˜
    private func generateSafeImageURL(for name: String, brand: String) -> String {
        // í–¥ìˆ˜ ì´ë¦„ê³¼ ë¸Œëœë“œë¥¼ ì¡°í•©í•˜ì—¬ ì¼ê´€ëœ ì‹œë“œ ìƒì„±
        let combined = "\(brand)\(name)".lowercased().replacingOccurrences(of: " ", with: "")
        let seed = abs(combined.hashValue) % 1000 + 1
        return "https://picsum.photos/200/300?random=\(seed)"
    }
}

// MARK: - Models

// Perfume íƒ€ì…ì€ Models/Perfume.swiftì—ì„œ ê°€ì ¸ì˜´

struct Review: Codable {
    let id: String
    let userId: String
    let userName: String
    let rating: Int
    let comment: String
    let date: Date
    
    enum CodingKeys: String, CodingKey {
        case id
        case userId = "user_id"
        case userName = "user_name"
        case rating
        case comment
        case date
    }
}

// MARK: - Cluster Recommendation Models

struct ClusterRecommendResponse: Codable {
    let cluster: Int
    let description: String
    let proba: [Double]
    let recommended_notes: [String]
    let selected_idx: [Int]
    let metadata: ClusterMetadata?
    
    struct ClusterMetadata: Codable {
        let model_version: String?
        let processing_time: Double?
        let confidence: Double?
    }
}

// MARK: - Network Models

struct PerfumeRecommendationItem: Codable {
    let perfumeName: String
    let perfumeBrand: String
    let score: Int?
    
    enum CodingKeys: String, CodingKey {
        case perfumeName = "perfume_name"
        case perfumeBrand = "perfume_brand"
        case score
    }
}

struct SaveRecommendationsRequest: Codable {
    let userId: String
    let recommendRound: Int
    let recommendations: [PerfumeRecommendationItem]
    
    enum CodingKeys: String, CodingKey {
        case userId = "user_id"
        case recommendRound = "recommend_round"
        case recommendations
    }
}

struct PerfumeFilters: Codable {
    let brand: String?
    let priceRange: ClosedRange<Double>?
    let gender: String?
    let sortBy: String?
    
    func toQueryItems() -> [URLQueryItem] {
        var items: [URLQueryItem] = []
        if let brand = brand {
            items.append(URLQueryItem(name: "brand", value: brand))
        }
        if let priceRange = priceRange {
            items.append(URLQueryItem(name: "min_price", value: String(priceRange.lowerBound)))
            items.append(URLQueryItem(name: "max_price", value: String(priceRange.upperBound)))
        }
        if let gender = gender {
            items.append(URLQueryItem(name: "gender", value: gender))
        }
        if let sortBy = sortBy {
            items.append(URLQueryItem(name: "sort_by", value: sortBy))
        }
        return items
    }
}

struct PerfumeDetailResponseData: Codable {
    let name: String
    let brand: String
    let imageUrl: String
    let notes: String?
    let emotionTags: String?
    
    enum CodingKeys: String, CodingKey {
        case name
        case brand
        case imageUrl = "image_url"
        case notes
        case emotionTags = "emotion_tags"
    }
    
    // PerfumeDetailResponseDataë¥¼ Perfume ëª¨ë¸ë¡œ ë³€í™˜
    func toPerfume() -> Perfume {
        return Perfume(
            id: "\(brand.lowercased().replacingOccurrences(of: " ", with: "_"))_\(name.lowercased().replacingOccurrences(of: " ", with: "_"))",
            name: name,
            brand: brand,
            imageURL: imageUrl.isEmpty ? generateSafeImageURL(for: name, brand: brand) : imageUrl,
            price: 0.0,
            description: notes ?? "\(brand)ì˜ \(name) í–¥ìˆ˜ì…ë‹ˆë‹¤.",
            notes: PerfumeNotes(top: [], middle: [], base: []),
            rating: 4.5,
            emotionTags: emotionTags?.split(separator: ",").map { String($0.trimmingCharacters(in: .whitespaces)) } ?? [],
            similarity: 0.0
        )
    }
    
    // ì•ˆì •ì ì¸ ì´ë¯¸ì§€ URL ìƒì„± í—¬í¼ í•¨ìˆ˜
    private func generateSafeImageURL(for name: String, brand: String) -> String {
        // í–¥ìˆ˜ ì´ë¦„ê³¼ ë¸Œëœë“œë¥¼ ì¡°í•©í•˜ì—¬ ì¼ê´€ëœ ì‹œë“œ ìƒì„±
        let combined = "\(brand)\(name)".lowercased().replacingOccurrences(of: " ", with: "")
        let seed = abs(combined.hashValue) % 1000 + 1
        return "https://picsum.photos/200/300?random=\(seed)"
    }
}

// MARK: - NetworkManager

class NetworkManager {
    static let shared = NetworkManager()
    let baseURL = "https://whiff-api-9nd8.onrender.com"
    
    private init() {}
    
    // MARK: - 1ì°¨ ì¶”ì²œ API (ê°ì • í´ëŸ¬ìŠ¤í„° ê¸°ë°˜)
    
    func getFirstRecommendations(preferences: PerfumePreferences, onRetry: ((Int) async -> Void)? = nil) async throws -> FirstRecommendationResponse {
        // ë°±ì—”ë“œ ê¶Œì¥: ìƒˆë¡œìš´ í´ëŸ¬ìŠ¤í„° ê¸°ë°˜ API ì‚¬ìš©
        let url = URL(string: "\(baseURL)/perfumes/recommend-cluster")!
        
        // ì¬ì‹œë„ ë¡œì§ (ìµœëŒ€ 3íšŒ)
        var lastError: Error?
        for attempt in 1...3 {
            do {
                print("ğŸš€ [1ì°¨ ì¶”ì²œ API ìš”ì²­] ì‹œë„ \(attempt)/3")
                
                // ì¬ì‹œë„ ìƒíƒœ ì—…ë°ì´íŠ¸
                await onRetry?(attempt)
                
                var urlRequest = URLRequest(url: url)
                urlRequest.httpMethod = "POST"
                urlRequest.setValue("application/json", forHTTPHeaderField: "Content-Type")
                urlRequest.timeoutInterval = 60.0  // 30ì´ˆ â†’ 60ì´ˆë¡œ ì¦ê°€
                
                // 1ì°¨ ì¶”ì²œì€ ë‹¨ìˆœí•œ ì„¤ë¬¸ ì‘ë‹µë§Œ ì „ì†¡ (ì›ë˜ëŒ€ë¡œ)
                let apiPreferences = preferences.toAPIFormat()
                
                // JSONEncoderë¥¼ ì‚¬ìš©í•´ì„œ êµ¬ì¡°ì²´ë¥¼ JSONìœ¼ë¡œ ì¸ì½”ë”©
                let encoder = JSONEncoder()
                urlRequest.httpBody = try encoder.encode(apiPreferences)
                
                // ìºì‹± ë°©ì§€ë¥¼ ìœ„í•œ í—¤ë” ì¶”ê°€
                let requestId = UUID().uuidString
                let timestamp = Date().timeIntervalSince1970
                urlRequest.setValue(requestId, forHTTPHeaderField: "X-Request-ID")
                urlRequest.setValue(String(timestamp), forHTTPHeaderField: "X-Timestamp")
                urlRequest.setValue("no-cache", forHTTPHeaderField: "Cache-Control")
                
                // ë””ë²„ê¹…ì„ ìœ„í•œ ìš”ì²­ ì •ë³´ ì¶œë ¥
                print("   URL: \(url.absoluteString)")
                print("   Timeout: 60ì´ˆ")
                print("   Request-ID: \(requestId)")
                if let bodyData = urlRequest.httpBody,
                   let bodyString = String(data: bodyData, encoding: .utf8) {
                    print("   Body: \(bodyString)")
                }
                
                let (data, httpResponse) = try await URLSession.shared.data(for: urlRequest)
                
                guard let httpResponse = httpResponse as? HTTPURLResponse else {
                    throw URLError(.badServerResponse)
                }
                
                print("ğŸ” [1ì°¨ ì¶”ì²œ API ì‘ë‹µ] ìƒíƒœ ì½”ë“œ: \(httpResponse.statusCode)")
                
                if let responseString = String(data: data, encoding: .utf8) {
                    print("ğŸ” [1ì°¨ ì¶”ì²œ API ì‘ë‹µ] Body: \(responseString.prefix(500))...")
                }
                
                guard httpResponse.statusCode == 200 else {
                    if let errorString = String(data: data, encoding: .utf8) {
                        print("âŒ [1ì°¨ ì¶”ì²œ API ì˜¤ë¥˜] \(httpResponse.statusCode): \(errorString)")
                    }
                    throw URLError(.badServerResponse)
                }
                
                // ì„±ê³µì ìœ¼ë¡œ ì‘ë‹µì„ ë°›ì€ ê²½ìš° ë””ì½”ë”© ì§„í–‰
                let decoder = JSONDecoder()
                
                do {
                    // ìƒˆë¡œìš´ í´ëŸ¬ìŠ¤í„° ì‘ë‹µ í˜•ì‹ìœ¼ë¡œ ë””ì½”ë”©
                    let clusterResponse = try decoder.decode(ClusterRecommendResponse.self, from: data)
                    
                    print("âœ… [1ì°¨ ì¶”ì²œ API ì„±ê³µ] í´ëŸ¬ìŠ¤í„°: \(clusterResponse.cluster), í–¥ìˆ˜: \(clusterResponse.selected_idx.count)ê°œ")
                    print("   ğŸ¯ ê°ì • í´ëŸ¬ìŠ¤í„°: \(clusterResponse.description)")
                    print("   ğŸ“Š í™•ë¥  ë¶„í¬: \(clusterResponse.proba.map { String(format: "%.2f", $0) }.joined(separator: ", "))")
                    print("   ğŸŒ¿ ì¶”ì²œ ë…¸íŠ¸: \(clusterResponse.recommended_notes.prefix(5).joined(separator: ", "))...")
                    
                    // ê¸°ì¡´ FirstRecommendationResponse í˜•ì‹ìœ¼ë¡œ ë³€í™˜
                    let items = clusterResponse.selected_idx.enumerated().map { index, perfumeIndex in
                        FirstRecommendationItem(
                            perfume_index: perfumeIndex,
                            emotion_cluster: clusterResponse.cluster,
                            cluster_proba: clusterResponse.proba[clusterResponse.cluster],
                            rank: index + 1
                        )
                    }
                    
                    let firstResponse = FirstRecommendationResponse(
                        recommendations: items,
                        clusterInfo: ClusterInfo(
                            cluster: clusterResponse.cluster,
                            description: clusterResponse.description,
                            proba: clusterResponse.proba,
                            recommended_notes: clusterResponse.recommended_notes,
                            selected_idx: clusterResponse.selected_idx
                        )
                    )
                    
                    return firstResponse
                    
                } catch {
                    print("âš ï¸ [í´ëŸ¬ìŠ¤í„° API ë””ì½”ë”© ì‹¤íŒ¨] ê¸°ì¡´ APIë¡œ í´ë°±: \(error)")
                    
                    // í´ë°±: ê¸°ì¡´ ë°©ì‹ìœ¼ë¡œ ì²˜ë¦¬
                    let items = try decoder.decode([FirstRecommendationItem].self, from: data)
                    let firstResponse = FirstRecommendationResponse(recommendations: items)
                    
                    print("âœ… [1ì°¨ ì¶”ì²œ API ì„±ê³µ] (í´ë°±) í–¥ìˆ˜ ê°œìˆ˜: \(firstResponse.recommendations.count)ê°œ")
                    return firstResponse
                }
                
            } catch {
                lastError = error
                print("âŒ [1ì°¨ ì¶”ì²œ API] ì‹œë„ \(attempt) ì‹¤íŒ¨: \(error)")
                
                // íƒ€ì„ì•„ì›ƒì¸ ê²½ìš° íŠ¹ë³„ ì²˜ë¦¬
                if let urlError = error as? URLError, urlError.code == .timedOut {
                    print("â° [íƒ€ì„ì•„ì›ƒ ê°ì§€] Render ì„œë²„ Cold Start ê°€ëŠ¥ì„±")
                    print("ğŸ’¡ [í•´ê²°ì±…] 15ë¶„ ë¹„í™œì„± í›„ ì²« ìš”ì²­ì€ ì‹œê°„ì´ ì˜¤ë˜ ê±¸ë¦½ë‹ˆë‹¤")
                }
                
                // ë§ˆì§€ë§‰ ì‹œë„ê°€ ì•„ë‹ˆë©´ ì¬ì‹œë„ ì „ ëŒ€ê¸°
                if attempt < 3 {
                    print("â³ [ì¬ì‹œë„ ëŒ€ê¸°] \(attempt * 2)ì´ˆ í›„ ì¬ì‹œë„...")
                    try? await Task.sleep(nanoseconds: UInt64(attempt * 2) * 1_000_000_000)
                }
            }
        }
        
        // ëª¨ë“  ì‹œë„ ì‹¤íŒ¨
        print("ğŸ’¥ [1ì°¨ ì¶”ì²œ API] ëª¨ë“  ì‹œë„ ì‹¤íŒ¨")
        throw lastError ?? URLError(.unknown)
    }
    
    // MARK: - 2ì°¨ ì¶”ì²œ API (ì‚¬ìš©ì ë…¸íŠ¸ ì ìˆ˜ ê¸°ë°˜)
    
    func getSecondRecommendations(
        userPreferences: PerfumePreferences?,
        userNoteScores: [String: Int],
        emotionProba: [Double],
        selectedIdx: [Int]
    ) async throws -> [SecondRecommendationItem] {
        
        let url = URL(string: "\(baseURL)/perfumes/recommend-2nd")!
        
        // ì¬ì‹œë„ ë¡œì§ (ìµœëŒ€ 3íšŒ)
        var lastError: Error?
        for attempt in 1...3 {
            do {
                print("ğŸš€ [2ì°¨ ì¶”ì²œ API ìš”ì²­] ì‹œë„ \(attempt)/3")
                
        var urlRequest = URLRequest(url: url)
        urlRequest.httpMethod = "POST"
        urlRequest.setValue("application/json", forHTTPHeaderField: "Content-Type")
                urlRequest.timeoutInterval = 60.0  // 30ì´ˆ â†’ 60ì´ˆë¡œ ì¦ê°€
        
        // ì‹¤ì œ ì‚¬ìš©ì ì„ í˜¸ë„ ì‚¬ìš© ë˜ëŠ” ê¸°ë³¸ê°’
        let preferences = if let userPrefs = userPreferences {
            UserPreferencesForSecond(from: userPrefs)
        } else {
            UserPreferencesForSecond()
        }
        
                // ğŸ”¥ ë³€í™˜ëœ ì‚¬ìš©ì ì„ í˜¸ë„ ìƒì„¸ í™•ì¸ (ì²« ë²ˆì§¸ ì‹œë„ì—ì„œë§Œ)
                if attempt == 1 {
        print("ğŸ”„ [ì‚¬ìš©ì ì„ í˜¸ë„ ë³€í™˜ ê²°ê³¼]")
        print("   - gender: '\(preferences.gender ?? "nil")'")
        print("   - season_tags: '\(preferences.season_tags ?? "nil")'")
        print("   - time_tags: '\(preferences.time_tags ?? "nil")'")
        print("   - desired_impression: '\(preferences.desired_impression ?? "nil")'")
        print("   - activity: '\(preferences.activity ?? "nil")'")
        print("   - weather: '\(preferences.weather ?? "nil")'")
                }
        
        // ğŸš¨ API ì œì•½ì‚¬í•­ í™•ì¸: selected_idx ìµœëŒ€ 20ê°œ
        var finalSelectedIdx = selectedIdx
        if selectedIdx.count > 20 {
            finalSelectedIdx = Array(selectedIdx.prefix(20))
                    if attempt == 1 {
            print("âš ï¸ [API ì œì•½ì‚¬í•­] selected_idxë¥¼ 20ê°œë¡œ ì œí•œ: \(selectedIdx.count)ê°œ â†’ \(finalSelectedIdx.count)ê°œ")
                    }
        }
        
        let requestBody = SecondRecommendationRequest(
            user_preferences: preferences,
            user_note_scores: userNoteScores,
            emotion_proba: emotionProba,
            selected_idx: finalSelectedIdx
        )
        
        let encoder = JSONEncoder()
        urlRequest.httpBody = try encoder.encode(requestBody)
        
        // ìºì‹± ë°©ì§€ë¥¼ ìœ„í•œ í—¤ë” ì¶”ê°€
        let requestId = UUID().uuidString
        let timestamp = Date().timeIntervalSince1970
        urlRequest.setValue(requestId, forHTTPHeaderField: "X-Request-ID")
        urlRequest.setValue(String(timestamp), forHTTPHeaderField: "X-Timestamp")
        urlRequest.setValue("no-cache", forHTTPHeaderField: "Cache-Control")
        
                // ë””ë²„ê¹…ì„ ìœ„í•œ ìš”ì²­ ì •ë³´ ì¶œë ¥ (ì²« ë²ˆì§¸ ì‹œë„ì—ì„œë§Œ)
                if attempt == 1 {
        print("   URL: \(url.absoluteString)")
                    print("   Timeout: 60ì´ˆ")
        print("   Request-ID: \(requestId)")
        print("   Timestamp: \(timestamp)")
        if let bodyData = urlRequest.httpBody,
           let bodyString = String(data: bodyData, encoding: .utf8) {
                        print("   Body: \(bodyString.prefix(300))...")
            }
        }
        
        let (data, urlResponse) = try await URLSession.shared.data(for: urlRequest)
        
        guard let httpResponse = urlResponse as? HTTPURLResponse else {
            throw URLError(.badServerResponse)
        }
        
        print("ğŸ” [2ì°¨ ì¶”ì²œ API ì‘ë‹µ] ìƒíƒœ ì½”ë“œ: \(httpResponse.statusCode)")
        
        if let responseString = String(data: data, encoding: .utf8) {
            print("ğŸ” [2ì°¨ ì¶”ì²œ API ì‘ë‹µ] Body: \(responseString.prefix(500))...")
        }
        
        guard httpResponse.statusCode == 200 else {
            if let errorString = String(data: data, encoding: .utf8) {
                print("âŒ [2ì°¨ ì¶”ì²œ API ì˜¤ë¥˜] \(httpResponse.statusCode): \(errorString)")
            }
            throw URLError(.badServerResponse)
        }
        
        // ì‘ë‹µì„ ë””ì½”ë”©
        let decoder = JSONDecoder()
        // APIê°€ ë°°ì—´ì„ ì§ì ‘ ë°˜í™˜í•˜ë¯€ë¡œ SecondRecommendationItem ë°°ì—´ë¡œ ë””ì½”ë”©
        let secondRecommendations = try decoder.decode([SecondRecommendationItem].self, from: data)
        
                // ğŸ”¥ ë…¸íŠ¸ í‰ê°€ ë°˜ì˜ë„ ë¶„ì„ (ì„±ê³µí•œ ê²½ìš°ì—ë§Œ)
        print("ğŸ“Š [2ì°¨ ì¶”ì²œ ê²°ê³¼ ë¶„ì„]")
        print("   âœ… ì´ ì¶”ì²œ ê°œìˆ˜: \(secondRecommendations.count)")
        
        // ì ìˆ˜ ë¶„í¬ í™•ì¸
        let scores = secondRecommendations.map { $0.final_score }
        if let minScore = scores.min(), let maxScore = scores.max() {
            let scoreRange = maxScore - minScore
            print("   ğŸ“ˆ ì ìˆ˜ ë²”ìœ„: \(String(format: "%.3f", minScore)) ~ \(String(format: "%.3f", maxScore))")
            print("   ğŸ“ˆ ì ìˆ˜ ì°¨ì´: \(String(format: "%.3f", scoreRange))")
            
            if scoreRange < 0.1 {
                print("   âš ï¸ ì ìˆ˜ ì°¨ì´ê°€ ë„ˆë¬´ ì‘ìŒ - ë…¸íŠ¸ í‰ê°€ê°€ ì œëŒ€ë¡œ ë°˜ì˜ë˜ì§€ ì•Šì„ ìˆ˜ ìˆìŒ")
            } else if scoreRange > 0.5 {
                print("   âœ… ì¶©ë¶„í•œ ì ìˆ˜ ì°¨ì´ - ë…¸íŠ¸ í‰ê°€ê°€ ì˜ ë°˜ì˜ë¨")
            }
        }
        
        // ë¸Œëœë“œ ë‹¤ì–‘ì„± í™•ì¸
        let brands = Set(secondRecommendations.map { $0.brand })
        print("   ğŸ·ï¸ ê³ ìœ  ë¸Œëœë“œ ìˆ˜: \(brands.count)ê°œ")
        
        // ê°ì • í´ëŸ¬ìŠ¤í„° ë¶„í¬ í™•ì¸
        let clusters = Set(secondRecommendations.map { $0.emotion_cluster })
        print("   ğŸ§  ê°ì • í´ëŸ¬ìŠ¤í„° ë‹¤ì–‘ì„±: \(clusters.count)ê°œ í´ëŸ¬ìŠ¤í„°")
        
                print("âœ… [2ì°¨ ì¶”ì²œ API ì„±ê³µ] \(secondRecommendations.count)ê°œ í–¥ìˆ˜ ì¶”ì²œ ë°›ìŒ")
                return secondRecommendations
                
            } catch {
                lastError = error
                print("âŒ [2ì°¨ ì¶”ì²œ API] ì‹œë„ \(attempt) ì‹¤íŒ¨: \(error)")
                
                // ë„¤íŠ¸ì›Œí¬ ì—°ê²° ì˜¤ë¥˜ì¸ ê²½ìš° íŠ¹ë³„ ì²˜ë¦¬
                if let urlError = error as? URLError {
                    switch urlError.code {
                    case .networkConnectionLost:
                        print("ğŸ“¡ [ë„¤íŠ¸ì›Œí¬ ì—°ê²° ëŠê¹€] ì¬ì—°ê²° ì‹œë„ ì¤‘...")
                    case .timedOut:
                        print("â° [íƒ€ì„ì•„ì›ƒ ê°ì§€] ì„œë²„ ì‘ë‹µ ì§€ì—°")
                    case .notConnectedToInternet:
                        print("ğŸŒ [ì¸í„°ë„· ì—°ê²° ì—†ìŒ] ë„¤íŠ¸ì›Œí¬ ìƒíƒœ í™•ì¸ í•„ìš”")
                    default:
                        print("ğŸ”— [ë„¤íŠ¸ì›Œí¬ ì˜¤ë¥˜] ì½”ë“œ: \(urlError.code.rawValue)")
                    }
                }
                
                // ë§ˆì§€ë§‰ ì‹œë„ê°€ ì•„ë‹ˆë©´ ì¬ì‹œë„ ì „ ëŒ€ê¸°
                if attempt < 3 {
                    let waitTime = attempt * 3  // 3ì´ˆ, 6ì´ˆ, 9ì´ˆ
                    print("â³ [ì¬ì‹œë„ ëŒ€ê¸°] \(waitTime)ì´ˆ í›„ ì¬ì‹œë„...")
                    try? await Task.sleep(nanoseconds: UInt64(waitTime) * 1_000_000_000)
            }
        }
        }
        
        // ëª¨ë“  ì‹œë„ ì‹¤íŒ¨
        print("ğŸ’¥ [2ì°¨ ì¶”ì²œ API] ëª¨ë“  ì‹œë„ ì‹¤íŒ¨")
        print("ğŸ” [ìµœì¢… ì˜¤ë¥˜] \(lastError?.localizedDescription ?? "ì•Œ ìˆ˜ ì—†ëŠ” ì˜¤ë¥˜")")
        throw lastError ?? URLError(.unknown)
    }
    
    // MARK: - í–¥ìˆ˜ ëª©ë¡ API
    
    func fetchPerfumes() async throws -> [Perfume] {
        let url = URL(string: "\(baseURL)/perfumes/")!
        var urlRequest = URLRequest(url: url)
        urlRequest.httpMethod = "GET"
        urlRequest.timeoutInterval = 60.0  // 30ì´ˆ â†’ 60ì´ˆë¡œ ì¦ê°€
        
        let (data, _) = try await URLSession.shared.data(for: urlRequest)
        let decoder = JSONDecoder()
        let apiResponse = try decoder.decode(APIResponse<PerfumesData>.self, from: data)
        
        return apiResponse.data.perfumes.map { $0.toPerfume() }
    }
    
    // MARK: - í–¥ìˆ˜ ìƒì„¸ ì •ë³´ API
    
    func fetchPerfumeDetail(name: String) async throws -> Perfume {
        guard let encodedName = name.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) else {
            throw URLError(.badURL)
        }
        
        let url = URL(string: "\(baseURL)/perfumes/\(encodedName)")!
        var urlRequest = URLRequest(url: url)
        urlRequest.httpMethod = "GET"
        urlRequest.timeoutInterval = 30.0
        
        let (data, _) = try await URLSession.shared.data(for: urlRequest)
        let decoder = JSONDecoder()
        let apiResponse = try decoder.decode(APIResponse<PerfumeDetailResponseData>.self, from: data)
        
        return apiResponse.data.toPerfume()
    }
    
    // MARK: - ë…¸íŠ¸ ë¶„ì„ API
    
    func getNoteAnalysis(perfumeIndex: Int) async throws -> NoteAnalysisResponse {
        let url = URL(string: "\(baseURL)/perfumes/note-analysis/\(perfumeIndex)")!
        var urlRequest = URLRequest(url: url)
        urlRequest.httpMethod = "GET"
        urlRequest.timeoutInterval = 30.0
        
        print("ğŸš€ [ë…¸íŠ¸ ë¶„ì„ API ìš”ì²­] URL: \(url.absoluteString)")
        
        let (data, urlResponse) = try await URLSession.shared.data(for: urlRequest)
        
        guard let httpResponse = urlResponse as? HTTPURLResponse else {
            throw URLError(.badServerResponse)
        }
        
        print("ğŸ” [ë…¸íŠ¸ ë¶„ì„ API ì‘ë‹µ] ìƒíƒœ ì½”ë“œ: \(httpResponse.statusCode)")
        
        guard httpResponse.statusCode == 200 else {
            if let errorString = String(data: data, encoding: .utf8) {
                print("âŒ [ë…¸íŠ¸ ë¶„ì„ API ì˜¤ë¥˜] \(httpResponse.statusCode): \(errorString)")
            }
            throw URLError(.badServerResponse)
        }
        
        let decoder = JSONDecoder()
        let noteResponse = try decoder.decode(NoteAnalysisResponse.self, from: data)
        
        print("âœ… [ë…¸íŠ¸ ë¶„ì„ API ì„±ê³µ] í–¥ìˆ˜ ì¸ë±ìŠ¤: \(perfumeIndex)")
        return noteResponse
    }
    
    // MARK: - ì‹œìŠ¤í…œ ìƒíƒœ API
    
    func getSystemStatus() async throws -> SystemStatusResponse {
        let url = URL(string: "\(baseURL)/perfumes/system-status")!
        var urlRequest = URLRequest(url: url)
        urlRequest.httpMethod = "GET"
        urlRequest.timeoutInterval = 30.0
        
        print("ğŸš€ [ì‹œìŠ¤í…œ ìƒíƒœ API ìš”ì²­] URL: \(url.absoluteString)")
        
        let (data, urlResponse) = try await URLSession.shared.data(for: urlRequest)
        
        guard let httpResponse = urlResponse as? HTTPURLResponse else {
            throw URLError(.badServerResponse)
        }
        
        print("ğŸ” [ì‹œìŠ¤í…œ ìƒíƒœ API ì‘ë‹µ] ìƒíƒœ ì½”ë“œ: \(httpResponse.statusCode)")
        
        guard httpResponse.statusCode == 200 else {
            if let errorString = String(data: data, encoding: .utf8) {
                print("âŒ [ì‹œìŠ¤í…œ ìƒíƒœ API ì˜¤ë¥˜] \(httpResponse.statusCode): \(errorString)")
            }
            throw URLError(.badServerResponse)
        }
        
        let decoder = JSONDecoder()
        let statusResponse = try decoder.decode(SystemStatusResponse.self, from: data)
        
        print("âœ… [ì‹œìŠ¤í…œ ìƒíƒœ API ì„±ê³µ] ìƒíƒœ: \(statusResponse.status)")
        return statusResponse
    }
    
    // MARK: - CSV ì •ë³´ API
    
    func getCSVInfo() async throws -> CSVInfoResponse {
        let url = URL(string: "\(baseURL)/perfumes/debug/csv-info")!
        var urlRequest = URLRequest(url: url)
        urlRequest.httpMethod = "GET"
        urlRequest.timeoutInterval = 30.0
        
        print("ğŸš€ [CSV ì •ë³´ API ìš”ì²­] URL: \(url.absoluteString)")
        
        let (data, urlResponse) = try await URLSession.shared.data(for: urlRequest)
        
        guard let httpResponse = urlResponse as? HTTPURLResponse else {
            throw URLError(.badServerResponse)
        }
        
        print("ğŸ” [CSV ì •ë³´ API ì‘ë‹µ] ìƒíƒœ ì½”ë“œ: \(httpResponse.statusCode)")
        
        guard httpResponse.statusCode == 200 else {
            if let errorString = String(data: data, encoding: .utf8) {
                print("âŒ [CSV ì •ë³´ API ì˜¤ë¥˜] \(httpResponse.statusCode): \(errorString)")
            }
            throw URLError(.badServerResponse)
        }
        
        let decoder = JSONDecoder()
        let csvResponse = try decoder.decode(CSVInfoResponse.self, from: data)
        
        print("âœ… [CSV ì •ë³´ API ì„±ê³µ] ì´ í–‰ ìˆ˜: \(csvResponse.info.total_rows)")
        return csvResponse
    }
    
    // MARK: - 2ì°¨ ì¶”ì²œ ì ìˆ˜ ì €ì¥ API
    
    func saveRecommendations(userId: String, recommendRound: Int, recommendations: [PerfumeRecommendationItem]) async throws {
        let url = URL(string: "\(baseURL)/recommendations/save")!
        var urlRequest = URLRequest(url: url)
        urlRequest.httpMethod = "POST"
        urlRequest.setValue("application/json", forHTTPHeaderField: "Content-Type")
        urlRequest.timeoutInterval = 30.0
        
        let requestBody = SaveRecommendationsRequest(
            userId: userId,
            recommendRound: recommendRound,
            recommendations: recommendations
        )
        
        let encoder = JSONEncoder()
        urlRequest.httpBody = try encoder.encode(requestBody)
        
        print("ğŸš€ [ì¶”ì²œ ì €ì¥ API ìš”ì²­] URL: \(url.absoluteString)")
        if let bodyData = urlRequest.httpBody,
           let bodyString = String(data: bodyData, encoding: .utf8) {
            print("   Body: \(bodyString)")
        }
        
        let (data, urlResponse) = try await URLSession.shared.data(for: urlRequest)
        
        guard let httpResponse = urlResponse as? HTTPURLResponse else {
            print("âŒ [ì¶”ì²œ ì €ì¥ API] ì‘ë‹µì„ HTTPURLResponseë¡œ ë³€í™˜í•  ìˆ˜ ì—†ìŒ")
            throw URLError(.badServerResponse)
        }
        
        print("ğŸ” [ì¶”ì²œ ì €ì¥ API ì‘ë‹µ] ìƒíƒœ ì½”ë“œ: \(httpResponse.statusCode)")
        
        // ì‘ë‹µ ë‚´ìš©ì„ í•­ìƒ ì¶œë ¥ (ì„±ê³µ/ì‹¤íŒ¨ ê´€ê³„ì—†ì´)
        if let responseString = String(data: data, encoding: .utf8) {
            print("ğŸ” [ì¶”ì²œ ì €ì¥ API ì‘ë‹µ] Body: \(responseString)")
        }
        
        // ìƒíƒœ ì½”ë“œë³„ ìƒì„¸ ì²˜ë¦¬
        switch httpResponse.statusCode {
        case 200:
            print("âœ… [ì¶”ì²œ ì €ì¥ API ì„±ê³µ] \(recommendations.count)ê°œ ì¶”ì²œ ì €ì¥ë¨")
        case 400:
            print("âŒ [ì¶”ì²œ ì €ì¥ API] ì˜ëª»ëœ ìš”ì²­ (400)")
            throw URLError(.badURL)
        case 401:
            print("âŒ [ì¶”ì²œ ì €ì¥ API] ì¸ì¦ ì˜¤ë¥˜ (401)")
            throw URLError(.userAuthenticationRequired)
        case 404:
            print("âŒ [ì¶”ì²œ ì €ì¥ API] ì—”ë“œí¬ì¸íŠ¸ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŒ (404)")
            throw URLError(.fileDoesNotExist)
        case 422:
            print("âŒ [ì¶”ì²œ ì €ì¥ API] ìœ íš¨ì„± ê²€ì‚¬ ì‹¤íŒ¨ (422)")
            throw URLError(.dataNotAllowed)
        case 500...599:
            print("âŒ [ì¶”ì²œ ì €ì¥ API] ì„œë²„ ë‚´ë¶€ ì˜¤ë¥˜ (\(httpResponse.statusCode))")
            throw URLError(.badServerResponse)
        default:
            print("âŒ [ì¶”ì²œ ì €ì¥ API] ì˜ˆìƒí•˜ì§€ ëª»í•œ ìƒíƒœ ì½”ë“œ: \(httpResponse.statusCode)")
            throw URLError(.badServerResponse)
        }
    }
    
    // MARK: - í–¥ìˆ˜ ë…¸íŠ¸ ì •ë³´ ì¡°íšŒ (2ì°¨ ì¶”ì²œìš©)
    
    func getPerfumeNotes(perfumeName: String) async throws -> PerfumeNotes {
        do {
            let perfume = try await fetchPerfumeDetail(name: perfumeName)
            return perfume.notes
        } catch {
            return PerfumeNotes(top: [], middle: [], base: [])
        }
    }
    
    // MARK: - í–¥ìˆ˜ ì¸ë±ìŠ¤ë¡œ í–¥ìˆ˜ ì •ë³´ ì¡°íšŒ
    
    func fetchPerfumeByIndex(_ index: Int) async throws -> Perfume {
        print("ğŸ” [í–¥ìˆ˜ ì¸ë±ìŠ¤ ì¡°íšŒ] ì¸ë±ìŠ¤: \(index)")
        
        // ì¬ì‹œë„ ë¡œì§ (ìµœëŒ€ 3íšŒ)
        var lastError: Error?
        for attempt in 1...3 {
        do {
                print("ğŸš€ [í–¥ìˆ˜ ì¸ë±ìŠ¤ API] ì‹œë„ \(attempt)/3")
                
            let url = URL(string: "\(baseURL)/perfumes/by-index/\(index)")!
            var urlRequest = URLRequest(url: url)
            urlRequest.httpMethod = "GET"
                urlRequest.timeoutInterval = 45.0  // 15ì´ˆ â†’ 45ì´ˆë¡œ ì¦ê°€
                
                // ìºì‹± ë°©ì§€ í—¤ë” ì¶”ê°€
                let requestId = UUID().uuidString
                urlRequest.setValue(requestId, forHTTPHeaderField: "X-Request-ID")
                urlRequest.setValue("no-cache", forHTTPHeaderField: "Cache-Control")
                
                print("   URL: \(url.absoluteString) (íƒ€ì„ì•„ì›ƒ: 45ì´ˆ)")
                
                let (data, response) = try await URLSession.shared.data(for: urlRequest)
                
                if let httpResponse = response as? HTTPURLResponse {
                    print("ğŸ“Š [í–¥ìˆ˜ ì¸ë±ìŠ¤ API] ì‘ë‹µ ì½”ë“œ: \(httpResponse.statusCode)")
                    
                    guard httpResponse.statusCode == 200 else {
                        if let errorString = String(data: data, encoding: .utf8) {
                            print("âŒ [í–¥ìˆ˜ ì¸ë±ìŠ¤ API ì˜¤ë¥˜] \(httpResponse.statusCode): \(errorString)")
                        }
                        throw URLError(.badServerResponse)
                    }
                }
                
            let decoder = JSONDecoder()
                
                // ë¨¼ì € APIResponse ë˜í¼ë¡œ ì‹œë„
                do {
            let apiResponse = try decoder.decode(APIResponse<PerfumeDetailResponseData>.self, from: data)
                    let perfume = apiResponse.data.toPerfume()
                    print("âœ… [í–¥ìˆ˜ ì¸ë±ìŠ¤ ì¡°íšŒ ì„±ê³µ] (APIResponse) \(perfume.brand) - \(perfume.name)")
                    print("ğŸ–¼ï¸ [ì´ë¯¸ì§€ URL] '\(perfume.imageURL)'")
                    
                    // ì´ë¯¸ì§€ URL ìœ íš¨ì„± ê²€ì¦
                    if perfume.imageURL.isEmpty || perfume.imageURL == "string" {
                        print("âš ï¸ [ì´ë¯¸ì§€ URL ë¬¸ì œ] ë¹ˆ URL ë˜ëŠ” ê¸°ë³¸ê°’ ê°ì§€, ì•ˆì „í•œ URLë¡œ êµì²´")
                        var fixedPerfume = perfume
                        fixedPerfume.imageURL = generateSafeImageURL(for: perfume.name, brand: perfume.brand, index: index)
                        return fixedPerfume
                    }
                    
                    return perfume
        } catch {
                    print("âš ï¸ [APIResponse ë””ì½”ë”© ì‹¤íŒ¨] ì§ì ‘ ë””ì½”ë”© ì‹œë„: \(error)")
                    
                    // ì§ì ‘ PerfumeDetailResponseDataë¡œ ë””ì½”ë”© ì‹œë„
                    do {
                        let perfumeData = try decoder.decode(PerfumeDetailResponseData.self, from: data)
                        let perfume = perfumeData.toPerfume()
                        print("âœ… [í–¥ìˆ˜ ì¸ë±ìŠ¤ ì¡°íšŒ ì„±ê³µ] (ì§ì ‘) \(perfume.brand) - \(perfume.name)")
                        print("ğŸ–¼ï¸ [ì´ë¯¸ì§€ URL] '\(perfume.imageURL)'")
                        
                        // ì´ë¯¸ì§€ URL ìœ íš¨ì„± ê²€ì¦
                        if perfume.imageURL.isEmpty || perfume.imageURL == "string" {
                            print("âš ï¸ [ì´ë¯¸ì§€ URL ë¬¸ì œ] ë¹ˆ URL ë˜ëŠ” ê¸°ë³¸ê°’ ê°ì§€, ì•ˆì „í•œ URLë¡œ êµì²´")
                            var fixedPerfume = perfume
                            fixedPerfume.imageURL = generateSafeImageURL(for: perfume.name, brand: perfume.brand, index: index)
                            return fixedPerfume
                        }
                        
                        return perfume
                    } catch {
                        print("âŒ [ì§ì ‘ ë””ì½”ë”©ë„ ì‹¤íŒ¨] \(error)")
                        if let responseString = String(data: data, encoding: .utf8) {
                            print("ğŸ” [ì‘ë‹µ ë‚´ìš©] \(responseString)")
                        }
                        throw error
                    }
                }
                
            } catch {
                lastError = error
                print("âŒ [í–¥ìˆ˜ ì¸ë±ìŠ¤ API] ì‹œë„ \(attempt) ì‹¤íŒ¨: \(error)")
                
                // íƒ€ì„ì•„ì›ƒì¸ ê²½ìš° íŠ¹ë³„ ì²˜ë¦¬
                if let urlError = error as? URLError, urlError.code == .timedOut {
                    print("â° [íƒ€ì„ì•„ì›ƒ ê°ì§€] Render ì„œë²„ Cold Start ê°€ëŠ¥ì„±")
                }
                
                // ë§ˆì§€ë§‰ ì‹œë„ê°€ ì•„ë‹ˆë©´ ì¬ì‹œë„ ì „ ëŒ€ê¸°
                if attempt < 3 {
                    let waitTime = attempt * 2  // 2ì´ˆ, 4ì´ˆ, 6ì´ˆ
                    print("â³ [ì¬ì‹œë„ ëŒ€ê¸°] \(waitTime)ì´ˆ í›„ ì¬ì‹œë„...")
                    try? await Task.sleep(nanoseconds: UInt64(waitTime) * 1_000_000_000)
                }
            }
        }
        
        print("âŒ [í–¥ìˆ˜ ì¸ë±ìŠ¤ API] ëª¨ë“  ì‹œë„ ì‹¤íŒ¨")
        
        // í´ë°± 1: ì „ì²´ ëª©ë¡ì—ì„œ ì°¾ê¸° (íƒ€ì„ì•„ì›ƒ ëŠ˜ë ¤ì„œ)
            do {
            print("ğŸ”„ [í´ë°± 1] ì „ì²´ í–¥ìˆ˜ ëª©ë¡ì—ì„œ ì¸ë±ìŠ¤ \(index) ì°¾ê¸°")
            let allPerfumes = try await fetchPerfumesWithRetry()
                if index < allPerfumes.count {
                let perfume = allPerfumes[index]
                print("âœ… [í´ë°± 1 ì„±ê³µ] \(perfume.brand) - \(perfume.name)")
                return perfume
            } else {
                print("âŒ [í´ë°± 1 ì‹¤íŒ¨] ì¸ë±ìŠ¤ \(index)ê°€ ë²”ìœ„ë¥¼ ë²—ì–´ë‚¨ (ì´ \(allPerfumes.count)ê°œ)")
                }
        } catch {
            print("âŒ [í´ë°± 1 ì‹¤íŒ¨] \(error)")
        }
            
        // í´ë°± 2: ë¡œì»¬ í˜„ì‹¤ì ì¸ í–¥ìˆ˜ ë°ì´í„°
        print("ğŸ”„ [í´ë°± 2] ë¡œì»¬ í˜„ì‹¤ì ì¸ í–¥ìˆ˜ ë°ì´í„° ì‚¬ìš©")
        let realisticPerfumes = PerfumeDataUtils.createRealisticPerfumes()
        if !realisticPerfumes.isEmpty {
            let perfumeIndex = index % realisticPerfumes.count
            let fallbackPerfume = realisticPerfumes[perfumeIndex]
            print("âœ… [í´ë°± 2 ì„±ê³µ] \(fallbackPerfume.brand) - \(fallbackPerfume.name)")
            return fallbackPerfume
        }
        
        // í´ë°± 3: ì•ˆì „í•œ ê¸°ë³¸ í–¥ìˆ˜ ìƒì„±
        print("ğŸ”„ [í´ë°± 3] ì•ˆì „í•œ ê¸°ë³¸ í–¥ìˆ˜ ìƒì„±")
        let safeImageURL = generateSafeImageURL(for: "í–¥ìˆ˜", brand: "ë¸Œëœë“œ", index: index)
            return Perfume(
                id: "perfume_\(index)",
                name: "í–¥ìˆ˜ #\(index)",
                brand: "ë¸Œëœë“œ",
            imageURL: safeImageURL,
                price: 0.0,
            description: "AI ì¶”ì²œ í–¥ìˆ˜ì…ë‹ˆë‹¤.",
                notes: PerfumeNotes(top: [], middle: [], base: []),
                rating: 4.0,
            emotionTags: ["AI ì¶”ì²œ"],
                similarity: 0.0
            )
        }
    
    // ì¬ì‹œë„ ë¡œì§ì´ í¬í•¨ëœ í–¥ìˆ˜ ëª©ë¡ ì¡°íšŒ
    private func fetchPerfumesWithRetry() async throws -> [Perfume] {
        var lastError: Error?
        for attempt in 1...2 {  // 2íšŒë§Œ ì‹œë„ (ë„ˆë¬´ ë§ì´ í•˜ë©´ ì˜¤ë˜ ê±¸ë¦¼)
            do {
                print("ğŸš€ [í–¥ìˆ˜ ëª©ë¡ API] ì‹œë„ \(attempt)/2")
                
                let url = URL(string: "\(baseURL)/perfumes/")!
                var urlRequest = URLRequest(url: url)
                urlRequest.httpMethod = "GET"
                urlRequest.timeoutInterval = 60.0  // 30ì´ˆ â†’ 60ì´ˆë¡œ ì¦ê°€
                
                let (data, _) = try await URLSession.shared.data(for: urlRequest)
                let decoder = JSONDecoder()
                let apiResponse = try decoder.decode(APIResponse<PerfumesData>.self, from: data)
                
                print("âœ… [í–¥ìˆ˜ ëª©ë¡ API ì„±ê³µ] \(apiResponse.data.perfumes.count)ê°œ í–¥ìˆ˜")
                return apiResponse.data.perfumes.map { $0.toPerfume() }
                
            } catch {
                lastError = error
                print("âŒ [í–¥ìˆ˜ ëª©ë¡ API] ì‹œë„ \(attempt) ì‹¤íŒ¨: \(error)")
                
                if attempt < 2 {
                    print("â³ [ì¬ì‹œë„ ëŒ€ê¸°] 3ì´ˆ í›„ ì¬ì‹œë„...")
                    try? await Task.sleep(nanoseconds: 3_000_000_000)
                }
            }
        }
        
        throw lastError ?? URLError(.unknown)
    }
    
    // ì•ˆì „í•œ ì´ë¯¸ì§€ URL ìƒì„± í—¬í¼ í•¨ìˆ˜
    private func generateSafeImageURL(for name: String, brand: String, index: Int) -> String {
        // í–¥ìˆ˜ ì´ë¦„ê³¼ ë¸Œëœë“œë¥¼ ì¡°í•©í•˜ì—¬ ì¼ê´€ëœ ì‹œë“œ ìƒì„±
        let combined = "\(brand)\(name)".lowercased().replacingOccurrences(of: " ", with: "")
        let seed = abs(combined.hashValue) % 1000 + 1
        
        // Picsumì„ ì‚¬ìš©í•˜ë˜, í–¥ìˆ˜ ê´€ë ¨ í‚¤ì›Œë“œë¡œ ë” ê´€ë ¨ì„± ìˆëŠ” ì´ë¯¸ì§€
        // 200x300ì€ í–¥ìˆ˜ë³‘ ë¹„ìœ¨ì— ì í•©
        return "https://picsum.photos/200/300?random=\(seed + index)"
    }
}

struct Store: Codable, Identifiable {
    let storeName: String
    let brand: String
    let lat: Double
    let lon: Double
    let address: String
    
    var id: String { storeName }
    
    enum CodingKeys: String, CodingKey {
        case storeName = "store_name"
        case brand
        case lat
        case lon
        case address
    }
}

enum NetworkError: Error {
    case invalidResponse
    case invalidData
    case decodingError
    case invalidURL
    case notFound
    case serverError
    case unknown
} 